<html> 
	<head> 
		<title>
			Three.js Experiments
		</title> 
		<style> 
			body { margin: 0; } 
			canvas { width: 100%; height: 100% } 
		</style> 
	</head> 
	<body> 
		<script src="three.min.js">
		</script> 
		<script> 
			var scene = new THREE.Scene(); 
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.01, 100000 ); 
			var renderer = new THREE.WebGLRenderer(); 
			
			renderer.setSize( window.innerWidth, window.innerHeight ); 
			document.body.appendChild( renderer.domElement ); 

			//Begining of code to retrieve the polygon vertex-coordinate list from render_info
				//var polylist = FileReader.readAsText(Blob|File, opt_encoding);
				var reader = new FileReader();
				reader.onload = function(e) {
  					var text = reader.result;
				}
				var polylist = reader.readAsText(render_info);
				alert(polylist);
			//EOC

			function refresh_render() {
				//Begining of code that takes polylist (list of polygons to make) and converts it into an array of coord[row][column] with the values listed
					var rows = polylist.split("\n").length;
					var line = polylist.split("\n");
					var coord = new Array();
					for(y=0;y<rows;y++) { 
						coord[y] = line[y].split(" ");
					}
				//EOC
				//Begining of code determing what is displayed, rather than if it is displayed
					var tri = new Array();
					var vertex = new Array();
					
					for(p=0;p<rows/3;p++){  //p is for polygon
						tri[p] = new THREE.Geometry();
						for(r=0;r<rows;r++) { //r is for row
							vertex[r] = new THREE.Vector3(coord[r][0],coord[r][1],coord[r][2]);
						}
						for(r=0;r<rows;r++) { //r is for row
							tri[p].vertices.push(vertex[r]);
						}					
						tri[p].faces.push(new THREE.Face3(2*p,2*p+1,2*p+2));
						
						var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
						var tri_fin = new THREE.Mesh(tri[p], material);
						scene.add(tri_fin);
					}
				//EOC
				//Begining of code determining where the camera is
					camera.position.z = 6; 
					
					var render = function () { 
						requestAnimationFrame( render ); 
						scene.rotation.x += 0.01; 
						//scene.rotation.y += 0.01; 
						renderer.render(scene, camera); 
					};
				//EOC 
				render();
			}
		</script> 
	</body> 
</html>